Direto no LeetCode.

A plataforma apresentava uma solução, que eu nem olhei.

Rapidinho.

Era para ser o problema do dia anterior, 18/11/2022. Mas, não tive tempo. Ou
não me dediquei tempo, apesar de ter entrado na plataforma.

Então, no dia seguinte, por ter ficado encucado, resolvi fazer. Até porque o
desse dia, 19, era meio chatinho. Nem tentei.

Inicialmente, fiz por um modelo recursivo, que é como costumo pensar, com uma
lógica bem interessante. Mas, com um modelo iterativo em mente.

Após dois errinhos por bobeira (pegadinhas do LeetCode), passou.

Após postar, resolvi verificar os demais e melhorei a ideia do iterativo.

Modelo 1 (GoLang): 4ms. Medianamente ruim. Memória, nem apareceu no gráfico.
Utilizava recursão, além de uma certa lógica matemática.

Modelo 2 (GoLang): 0ms. Melhor, impossível. Memória, também não aparecia no
gráfico. Era um modo iterativo, bem implementado.

Todas as postagens que eu vi baseavam-se na mesma ideia, modular (resto de
divisão sendo zero) para as combinações.

Porém, algumas postagens eram relativamente complexas (ou feias).

=====
Em 03/02/2026, fiz modelos em Rust.

Basicamente, as traduções dos modelos em GoLang.

Após postar, vi que poderia melhorar, um pouco, uma lógica. Então, fiz um
terceiro modelo.

Modelo 1 (Rust): 0ms. Melhor, impossível. Memória, mediana. Tradução do primeiro]
modelo em GoLang.

Modelo 2 (Rust): 0ms. Melhor, impossível. Memória, excelente. Tradução do
segundo modelo em GoLang.

Modelo 3 (Rust): 0ms. Melhor, impossível. Memória, mediana. Mas foi a pior de
todas. Era um ajuste do modelo anterior, visando diminuir a quantidade de linhas
e aplicar melhor uma lógica.

O melhor modelo, em termos de memória, foi o segundo, que é iterativo. Como a
plataforma não é confiável para comparações, vê que um ajuste desse segundo
modelo, pensando em diminuir o próprio código, e não houve outras inserções,
ficou pior que o recursivo.
