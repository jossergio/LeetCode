Direto no LeetCode e pelo tablet.

A plataforma me apresentava uma solução, que eu nem olhei.

Após postar, vi que as ideias eram similares. Porém, a minha tinha um aspecto um
pouco mais genérico e a da plataforma fazia um processamento a mais baseado nas
dicas do problema, que eu ignorei, pois não considerei interessante ou eficiente
fazer dessa forma.

Após postar, veio-me uma nova forma de implementação. Então, fiz uma segunda
postagem.

Em Rust, para praticar, inclusive recursos de iteradores e de linha única,
apesar de subdividida.

Modelo 1 (Rust): 0ms. Melhor, impossível. Memória, mediana.

Modelo 2 (Rust): 0ms. Melhor, impossível. Memória, excelente. Era o mesmo do
modelo anterior, com uma leve adaptação. Em termos de sub-linhas, aumentou em
uma. No lugar de fazer a contagem do iterador, o transformava (collect) em um
vetor e utilizava seu tamanho, para a resposta.

Em 0ms, a cópia fiel do modelo da plataforma. Muitos códigos que eu vi, em
diferentes áreas de memória do gráfico, eram essa cópia. Ou seja: mesmo em
termos de memória, o ambiente do LeetCode não é tão homogêneo.

Na mesma barra do gráfico de memória do segundo modelo, um código comum (laço
com um contador, para formar a resposta).
