Direto no LeetCode e pelo tablet.

A plataforma me apresentava uma solução, que eu nem olhei.

Após postar, vi que eu realizava um cálculo para ver se um valor tinha parte
fracionada. Então, fiz uma segunda postagem, para utilizar uma função embutida
para checar essa condição diretamente.

Em seguida, fiz um terceiro modelo, tentando otimizar, já que, por ser baseado
em adição, e o resultado não depende da ordem dos fatores, não precisaria fazer
um laço dentro de outro em forma O(n^2), mas um O(n*log n), e contar cada passo
como duplo. Observei isso vendo as postagens dos demais.

Em todos eles, era utilizado um ponto de saída antecipado no laço interno.

O modelo da plataforma também era com esse laço duplo O(n^2), apesar de utilizar
outras funções embutidas para fazer as comparações.

Modelo 1 (Rust): 1ms. Muito bom. Memória, mediana. Utilizava um cálculo para ver
se ficava sobra decimal.

Modelo 2 (Rust): 5ms. Mediano. Memória, mediana. Era o anterior, porém,
utilizando outras funções embutidas de forma mais direta, evitando cálculos
adicionais.

Modelo 3 (Rust): 0ms. Melhor, impossível. Memória, mediana. Era o mesmo modelo
antereior, porém otimizando os laços.

Inicialmente, eu tinha testado fazer de uma forma mais lógica, dentro dos
limites da questão, mas a parte mais interessante, mesmo, era se o resultado era
inteiro ou não.

Nas postagens dos demais, não vi nada extraordinário. Nem sobre a linguagem,
nem sobre ideias de implementação ou de lógica.
