Direto no LeetCode e pelo tablet.

Era o mesmo problema do dia 09/05/2024, que eu havia feito dois modelos em C++.

Porém, no lugar de simplesmente repostar, tive a ideia de fazer em Rust. E fiz
dois modelos, cada um baseado nas estruturas utilizadas na postagem anterior,
porém, especialmente no primeiro, abusando da forma Rust de programar e
adicionando pequenos detalhes visando otimizar.

Modelo 1 (Rust): 34ms. Ruim. Memória, quase top das galáxias. Utilizava um heap
(BinaryHeap) para estruturar a ordenação e adicionava uma condição para sair
antecipadamente (coisa que não existia no modelo em C++ que serviu de base).

Modelo 2 (Rust): 19ms. Muito bom. Memória, mediana. Gerava uma ordem inversa e
seguia uma estruturação bem parecida com o modelo em C++ que serviu de base.

Os códigos eram bem parecidos, apesar de implementações com detalhes diferentes.
