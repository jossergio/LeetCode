Direto no LeetCode e pelo tablet.

A plataforma me apresentava uma solução, que eu nem olhei.

Apesar de ser considerado um problema simples, antes de visualizar, na tabela de
problemas, vi que cerca de 50% era de insucesso. Ou seja: havaria alguns leves
detalhes que poderiam atrapalhar.

E houve.

Após três errinhos, passou.

O primeiro, por considerar uma forma de solução, que não era. A segunda por
achar que tudo caberia em um inteiro, e não cabia. E a terceira por achar que
tudo caberia em um inteiro maior (i64, de Rust); e não coube.

Então, tive uma ideia de não precisar de fazer o acumulador crescer, mantendo,
somente, o valor necessário para o próximo passo (módulo). Passou.

Após postar, vi que minha ideia era bem similar à da plataforma, alterando
pequenos detalhes que, acho, acaba agilizando o meu.

Vendo as postagens dos demais, e por ter feito em Rust, vi uma forma de criar um
modelo mais rusticiano, com linha única, apesar de que dividida, e, de quebra,
aprendar mais uma funcionalidade de iteradores. Então, fiz uma segunda postagem.

Modelo 1 (Rust): 0ms. Melhor, impossível. Memória, excelente do topo dos tops
das galáxias. Era um modelo de programação mais geral.

Modelo 2 (Rust): 0ms. Melhor, impossível. Memória, medianamente boa. Era uma
forma mais rusticiana, com linha única, apesar de quebrada.

Em 0ms, uma ideia bem similar à minha primeira. Porém, tinha uma leve
redundãncia em um cálculo, que por sinal era desnecessária.

A dica da plataforma ajudava um pouco. Porém, não citava a questão do módulo,
importante para trabalar com grandes valores. Acho que essa era a pegadinha, que
eu tinha imaginado, pois não havia necessidade, mesmo, de informar na descrição
do problema.
