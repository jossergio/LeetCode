Direto no LeetCode e pelo tablet.

A plataforma me apresentava uma solução, que eu nem olhei.

Após um errinho, por uma complexidade do cálculo, passou.

Após postar, vi que minha ideia era bem complexa, comparada ao modelo da
plataforma. Então, fiz um segundo modelo, tanto mais rusticiano quanto um pouco
mais simples, baseado na lógica do cálculo da plataforma, que era o mesmo tanto
para o momento que avança quanto o que retroage.

Modelo 1 (Rust): 3ms. Mediano. Memória, horrível. Utilizava um laço, onde ía
atualizando um vetor resposta, já pronto com valores zerados, e conforme uma
lógica do problema. Ficou um pouco prolixo, especialmente no cálculo retrógrado.

Modelo 2 (Rust): 0ms. Melhor, impossível. Memória, excelente. Utilizava um
iterador, para formar o vetor resposta, com uma mesma lógica aplicada tanto
o que avança quanto para o retrógrado. Só não ficou em linha única pois criei
uma variável para manter um valor que seria bastante utilizado o cálculo.

Muitos códigos diferentes. Nenhum baseado em iteradores na forma que a
plataforma apresentava, apesar de haver iteradores. Muitos com laços comuns.
