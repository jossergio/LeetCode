Brincando de testar GoLang

Projeto bem simples. Porém, resultou muito lento, comparado com outros
que participaram do desafio.

Testado no ambiente Playground da páginda da linguagem
(https://play.golang.org)

Feito de forma direta, pela simplicidade, e transcrito na área de avaliação
do LeetCode.

Ah! Refletir sobre a inicialização dos retornos em {0, 0} e a subtração antes
do retorno independente de ter encontrado ou não.

Porém, esse algoritmo está na casa dos que utilizam pouca memória.

===================
Em 06/08/2022, um ano depois, fiz uma atualização, para tentar deixar
em O (n log(n)), através de técnica de dois ponteiros. E acabei utilizando C++,
por precisar de uma ordenação de vetor. Além disso, precisaria criar uma
estrutura com pair e fazer uma ordem personalizada com essa estrutura.

Acabou utilizando muita memória. Muita, mesmo. Mas, ficou mediano. Houve casos
bem piores. C++ é que utiliza mais memória que GoLang.

E ficou em 27ms. Mediano.

====================
Em 08/08/2022, pela simplicidade do problema, e visando estudar Rust, fiz uma
versão, baseada no modelo 1.

Apesar de que tive que utilizar, para responder, algumas estruturas mais
complexas, como vec, ainda assim foi bastante útil para entender a linguagem.

Foi o primeiro modelo de solução que postei nessa linguagem.

Ficou em 39ms. Ruim. Memória, quase excelente.

Nos modelos em Rust que olhei, vi que ainda há muitos recursos a serem
estudados.

=====================
Em 05/01/2023, também visando estudar Rust, fiz uma nova versão, visando reduzir
o código, utilizando as estruturas da linguagem mais eficientemente.

40ms. Ruim.

Memória, igual ao anterior e quase excelente.

